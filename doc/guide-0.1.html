<html>

<head>
<title>Welcome to libkml version 0.1 ALPHA</title>
</head>

<body>
<h3>Welcome!</h3>

<p>
Welcome to the first public PREVIEW release of libkml!
</p>

<h3>What is libkml?</h3>

<p>
This is a library to parse, serialize and
programmatically access a KML document object model (DOM).
The main API is C++, and there are bindings to Python, Ruby,
PHP, Perl, and Java.
</p>

<h3>Licensing</h3>

<p>
The libkml software is distributed under the new BSD license
whose text is found at the top of each file.
</p>

<h3>Supported platforms</h3>

<p>
This library supports Windows XP, Mac OSX 10.4 and 10.5,
and Linux.
</p>

<h3>Building and installing libkml</h3>

<p>
To build and install libkml from source you first need to
install SCons version 0.97 available at
<a href="http://www.scons.org/">http://www.scons.org/</a>.
Use the PREFIX argument as follows to install libkml in
a location other than the default:
</p>

<pre>
scons PREFIX=/your/root install
</pre>

<p>
You may also use LIBDIR and INCDIR to specify completely
separate lib and include directories.
</p>

<p>
Expat version 2.0.1 is the XML parser used in libkml.
Expat is available at
<a href="http://expat.sourceforge.net/">http://expat.sourceforge.net</a>.
You tell SCons where to find the Expat library and header files like so:
</p>

<pre>
scons EXPAT_LIBDIR=/your/root/lib EXPAT_INCDIR=/your/root/include
</pre>

<p>
Note: on Linux and Mac, EXPAT_INCDIR defaults to <tt>/usr/local/include</tt>
and EXPAT_LIBDIR defaults to <tt>/usr/local/lib</tt>.
This matches Expat's own installation defaults.
</p>

<p>
If you want to create bindings for the supported scripting languages
you need to install the Simplified Wrapper and Interface Generator (SWIG)
version 1.3.33.
Once SWIG is installed the language bindings are created by default.
You may explicitly disable the building of
the SWIG extensions by using the RUNSWIG option in SCons as follows:
</p>

<pre>
scons RUNSWIG=0  # 0 means to <i>not</i> build SWIG extensions
</pre>

<h3>Running the unit tests</h3>

<p>
The libkml system includes a large suite of unit tests, written against the
CppUnit framework available at
<a href="http://cppunit.sourceforge.net/">http://cppunit.sourceforge.net</a>.
Once you have have installed CppUnit you can build the tests as follows:
</p>

<pre>
scons CPPUNIT_LIBDIR=/your/root/lib CPPUNIT_INCDIR=/your/root/include
</pre>

<p>
Note: on Linux and Mac, CPPUNIT_INCDIR defaults to /usr/local/include and
CPPUNIT_LIBDIR defaults to /usr/local/lib. This matches CppUnit's own
installation defaults.
</p>

<p>
To run the tests, invoke SCons as follows:
</p>

<pre>
scons runtests
</pre>

<p>
The test output looks as follows:
</p>

<pre>
...
kmz_test PASSED (Test Binaries: 1 passed, 0 failed)
...
abstractlatlonbox_test PASSED (Test Binaries: 2 passed, 0 failed)
...
...
xsd_test PASSED (Test Binaries: 42 passed, 0 failed)
...
</pre>


<h3>Hello libkml</h3>
<p>
Here are some small sample programs to show you how to
program with libkml.
</p>

<pre>
// This program parses a KML Placemark from a memory buffer and prints
// the value of the &lt;name&gt; element on standard output.

#include &lt;iostream&gt;
#include &lt;string&gt;
#include "kml/dom.h"  // The KML DOM header.

int main() {
  // Parse KML from a memory buffer.
  std::string errors;
  kmldom::Element* element = kmldom::Parse(
    "&lt;Placemark&gt;&lt;name&gt;hi&lt;/name&gt;&lt;/Placemark&gt;",
    &errors);

  // Convert the type of the root element of the parse.
  const kmldom::Placemark* placemark = kmldom::AsPlacemark(element);

  // Access the value of the <name> element.
  std::cout &lt;&lt; "The Placemark name is: " &lt;&lt; placemark-&gt;name()
    &lt;&lt; std::endl;

  // Release memory
  delete element;
}
</pre>

<p>
Another example:
</p>

<pre>
// This program uses the KmlFactory to create a Point Placemark and
// prints the resultant KML on standard output.

#include &lt;iostream&gt;
#include &lt;string&gt;
#include "kml/dom.h"

// libkml types are in the kmldom namespace
using kmldom::Coordinates;
using kmldom::Kml;
using kmldom::KmlFactory;
using kmldom::Placemark;
using kmldom::Point;

int main() {
  // Get the factory singleton to create KML elements.
  KmlFactory* factory = KmlFactory::GetFactory();

  // Create &lt;coordinates&gt;.
  Coordinates* coordinates = factory-&gt;CreateCoordinates();
  // Create &lt;coordinates&gt;-122.0816695,37.42052549&lt;coordinates&gt;
  coordinates-&gt;add_point2(-122.0816695,37.42052549);

  // Create &lt;Point&gt; and give it &lt;coordinates&gt;.
  Point* point = factory-&gt;CreatePoint();
  point-&gt;set_coordinates(coordinates);  // point takes ownership

  // Create &lt;Placemark&gt; and give it a &lt;name&gt; and the &lt;Point&gt;.
  Placemark* placemark = factory-&gt;CreatePlacemark();
  placemark-&gt;set_name("Cool Statue");
  placemark-&gt;set_geometry(point);  // placemark takes ownership

  // Create &lt;kml&gt; and give it &lt;Placemark&gt;.
  Kml* kml = factory-&gt;CreateKml();
  kml-&gt;set_feature(placemark);  // kml takes ownership.

  // Serialize to XML
  std::string xml = kmldom::SerializePretty(*kml);

  // Print to stdout
  std::cout &lt;&lt; xml;

  // Release memory
  delete kml;  // Frees all child elements
}
</pre>

<h3>Example programs</h3>

[TODO: links to directories]

<p>
The libkml system comes with a small suite of example programs to help
you get started.
First build and install libkml as described above.
Then build the 'helloworld' examples as follows:
</p>

<pre>
cd examples/helloworld
scons LIBKML_LIBDIR=/your/root/lib LIBKML_INCDIR=/your/root/include
</pre>

<p>
If you do not supply an explicit LIBKML_LIBDIR or LIBKML_INCDIR, the libraries
and headers in the build directory will be used.
</p>

<h3>Quick reference</h3>

<h4>kmldom</h4>

<p>
The libkml system presently consists of the KML DOM.
All classes and functions in the KML DOM are in the
<b>kmldom</b>
namespace.
</p>

<h4>KML 2.2</h4>

<p>
The libkml DOM implements KML 2.2 as documented here:
<a
href="http://code.google.com/apis/kml/documentation/kml_tags_beta1.html">href="http://code.google.com/apis/kml/documentation/kml_tags_beta1.html</a>.
Note that this is the version of candidate OGC KML 2.2 standard here:
<a
href="http://www.opengeospatial.org/standards/requests/45">http://www.opengeospatial.org/standards/requests/45</a>.
</p>

<h4>Creating complex elements</h4>

<p>
Each complex element in KML 2.2 has a C++ type whose name
is the same as the element.  For example, &lt;Placemark&gt;
is kmldom::Placemark, and &lt;GroundOverlay&gt; is kmldom::GroundOverlay.
</p>

<p>
The KmlFactory singleton has a method to create each complex element:
</p>

<pre>
KmlFactory* factory = kmldom::KmlFactory::GetFactory();
kmldom::Placemark* placemark = factory->CreatePlacemark();
kmldom::Folder* folder = factory->CreateFolder();
</pre>

<h4>Memory management</h4>

<p>
The caller owns any element created by the factory.
Ownership is transferred to the KML DOM if and when
<tt>set_xxx()</tt> or <tt>add_xxx</tt> is used to make the
element a child of the given parent.
An element has at most one parent.
Once an element is set to a given parent, it cannot be detached.
The <tt>clear_xxx()</tt> method both removes the child from the parent
and released its storage.
Removing a given element also releases the storage of all of its children.
</p>

<p>
Storage of owned elements is released as follows:
</p>

<pre>
factory->DeleteElement(placemark);
factory->DeleteElement(folder);
</pre>

<h4>Setting simple elements</h4>

<p>
Each simple element in KML 2.2 is a field in a complex element.
The library provides accessor functions to set, get, clear, and discover the
existence of a given simple element.
</p>
<p>
For example, any Feature (such as Placemark) has a &lt;name&gt;
that can be manipulated with these methods:
</p>

<pre>
const std::string&amp; name() const;
bool has_name() const;
void set_name(const std::string&amp; value);
void clear_name();
</pre>

<p>
Note that the getter is always <tt>const</tt>.
</p>
<p>
The <tt>has_xxx()</tt> method returns <tt>true</tt> if this element was in
the parsed KML or if it was previously set using <tt>set_xxx()</tt>.
</p>
<p>
The <tt>clear_xxx()</tt> method removes any value set either by the parser
or by the <tt>set_xxx()</tt> method.
On serialization, no element is emitted for an element that has been cleared.
</p
<p>
The getter <i>always</i> returns a value, irrespective of the
state returned by <tt>has_xxx()</tt>.
If <tt>has_xxx()</tt> is false the getter
returns the default for this element, as specifed in the KML Reference.
</p>

<p>
Simple elements are of either <tt>std::string</tt>, <tt>double</tt>,
<tt>int</tt>, <tt>boolean</tt> or <tt>enum</tt> type.
</p>

<p>
Here is how to access the &lt;description&gt; element:
</p>

<pre>
const std::string&amp; name() const;
bool has_name() const;
void set_name(const std::string&amp; value);
void clear_name();
</pre>

<p>
Here is how to access the &lt;north&gt; element:
</p>

<pre>
double north() const;
void set_north(double north);
bool has_north() const;
void set_north(bool north);
</pre>

<p>
Here is how to access the &lt;drawOrder&gt; element.
Note that the name of the element in the accessor function
is folded to all lower case:
</p>

<pre>
int draworder() const;
void set_draworder(bool draworder);
bool has_draworder() const;
void clear_draworder();
</pre>

<p>
Here is how to access the &lt;visibility&gt; element:
</p>

<pre>
bool visibility() const;
void set_visibility(bool visibility);
bool has_visibility() const;
void clear_visibility();
</pre>


<p>
Here is how to access the &lt;altitudeMode&gt; element:
</p>

<pre>
int altitudemode() const;
void set_altitudemode(int altitudemode);
bool has_altitudemode() const;
void clear_altitudemode();
</pre>

<h4>Enumerated value elements</h4>

<p>
Every enumerated value element has a C++ <tt>enum</tt>.
For example, here is the <tt>enum</tt> for &lt;altitudeMode&gt;:
</p>

<pre>
typedef enum {
  ALTITUDEMODE_CLAMPTOGROUND = 0,
  ALTITUDEMODE_RELATIVETOGROUND,
  ALTITUDEMODE_ABSOLUTE
} AltitudeModeEnum;
</pre>

<p>
The <tt>enum</tt> type name is the element name with a leading capital
and the string 'Enum' appended to it.
Thus &lt;colorMode&gt; is of ColorModeEnum, and &lt;listItemType&gt;
is ListItemTypeEnum.
</p>

<h4>More on complex elements</h4>

<p>
Note that the <tt>get_xxx()</tt> method for a complex element
returns a <tt>const</tt> pointer.
This is to help indicate that the element is now owned by
the parent and cannot be manipulated further.
</p>
<p>
There are 3 kinds of complex child accessors:
1) single value of a specific type,
2) single value of a group type, and
3) an array value of either a specific or group type.
Here are examples of each.
</p>

<p>
The &lt;LatLonBox&gt; child of &lt;GroundOverlay&gt; is
an example of a complex child of a specific type:
</p>

<pre>
const LatLonBox* latlonbox() const;
void set_latlonbox(LatLonBox* latlonbox);
bool has_latlonbox() const;
void clear_latlonbox();
</pre>

<p>
The AbstractView child of Feature is an example
of a complex child of a group type.  Both &lt;LookAt&gt; and &lt;Camera&gt;
can be used with these accessors.
</p>

<pre>
const AbstractView* abstractview() const;
void set_abstractview(AbstractView* abstractview);
bool has_abstractview() const;
void clear_abstractview();
</pre>

<p>
The Feature child of &lt;Folder&gt; is an example
of an array value of a group type:
</p>

<pre>
void add_feature(Feature* feature);
size_t feature_array_size() const;
const kmldom::Feature* feature_array_at(unsigned int index) const;
</pre>

<p>
(Note that in KML 2.2 the following elements
are all of Feature type: Placemark, NetworkLink, GroundOverlay,
ScreenOverlay, PhotoOverlay, Folder, and Document).
</p>

<h4>
Type inspection and conversion
</h4>

<p>
All complex elements are derived from <tt>kmldom::Element</tt>.
There is a type conversion and inspection function for
each complex type.
The libkml system is not built with run-time type information (RTTI),
hence <tt>dynamic_cast</tt> is not used.
If the element is of the desired type, then a pointer of
that type is returned, else NULL.
</p>
<p>
For example, the following coded accesses the Geometry of a Placemark
to discover if it is a Point:
</p>

<pre>
const Placemark* placemark;
...
if (placemark-&gt;has_geometry()) {
  if (const kmldom::Point* point = kmldom::AsPoint(placemark-&gt;geometry()) {
    // Yes, it is a Point... see if it has coordinates:
    if (point-&gt;has_coordinates()) {
      ...
    }
  }
}
</pre>

<p>
Every element has a type id that can be accessed with the Type() method:
</p>

<pre>
const Feature* feature = kml->feature();
if (feature-&gt;Type() == Type_Placemark) {
  // Yes, this is a Placemark
}
</pre>

<p>
Every element has a IsA() method to inquire the specific or group
type of an element:
</p>

<pre>
GroundOverlay* overlay = KmlFactory()-&gt;CreateGroundOverlay();
assert(overlay-&gt;IsA(kmldom::Type_Object));
assert(overlay-&gt;IsA(kmldom::Type_Feature));
assert(overlay-&gt;IsA(kmldom::Type_Overlay));
assert(overlay-&gt;IsA(kmldom::Type_GroundOverlay));
</pre>


<h3>THIS IS ALHPA SOFTWARE</h3>
<p>
Expect changes.
Do NOT use in production code.
</p>
<p>
This is an initial preview of libkml and while the interfaces
described are now fairly stable, there is the potential for change!
However, as KML 2.2 advances through the OGC to a full standard,
the language itself is stable and it is the intention of libkml
to adhere strictly to the OGC KML 2.2 standard.
</p>

<h3>Future development</h3>

<p>
As the PREVIEW and "0.1" language indicates we have much more
in mind for the future.
While parsing to, and serializing from and programmatic access to the
raw KML DOM are reasonably useful and encode some important KML
semantics, there are higher level semantics and functionality of KML
to support.
These include resolving the Style for a Feature, expanding the balloon text,
managing the id's in a KML file, fetching a NetworkLink, finding
the Features in a given bounding box, etc.
We intend to offer such higher level semantics and processing functionality
in future releases of libkml.
</p>

<h3>Feedback?</h3>

<p>
[TODO: how to post bugs, etc]
</p>

</body>
</html>
